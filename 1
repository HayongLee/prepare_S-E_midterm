chapter 1

 CHAPTER 1
소프트웨어를 만드는 절차를 어떻게 할 것인가가 소프트웨어 공학의 목표
팀의 분위기 / 코딩 스타일 파악 / 팀의 도구 파악

워터폴 모델 (대표적인 소프트웨어 공학모델)

requirements
명세서 만드는 것
무슨 기능을 짤것인지 정의한다.
커스터머와 개발자가 협의를 하는 과정
기능에 대한 요구사항 – functional requirements
퍼포먼스에 대한 제약 – non functional requirements

design

UML로 소프트웨어를 설계하는 것 함수 / 모듈 / 클래스 등을 정의 한다.

implementation

버젼 컨트롤 시스템 (git)로 효율적인 코드를 짠다. Vcs를 이용하면 효율적인 시간관리 및 누가 어떤 부분을 짤것인지 체계적으로 나눌 수 있음

verification

junit 같은 자동화 시켜주는 도구를 이용해 이 소프트웨어에 디펙은 없는지 확인한다.

Maintenance

유지보수 단계 (소프트웨어 공학의 존재 이유) 이면서 기능은 그대로 하면서 함수는 짧게 구조적으로 기능을 나눈다. 남이 알아봐도 쉽게 리팩토링 및 클린 코드 과정이다.
쉽게는 줄 맞춤 부터 변수이름 함수이름을 변경하면서 알아보기 쉽게 만든 다음 주석을 제거시킨다.

소프트웨어는 눈에 보이는 것이 아니기 때문에 만드는 과정이 구체화되지 않아서 소프트웨어 공학 기법을 이용해 효율적인 리소스 관리가 필요하다.

커스터머가 원하는 것을 만들기 위해 가장 좋은 방법은 에자일 디벨롭먼트를 사용하는 것이며 커스터머의 적극적인 협조가 프로젝트를 완성시키는 지름길이다.
다큐먼트는 중요하지만 문서자체를 줄이도록 노력하고 코드를 명확하게 보여주도록(리팩토링)하는 것이 중요하다.

팀원과의 커뮤니케이션도 보여지는 것보다 훨씬 중요하며 소프트웨어를 만드는 과정에서 시간관리에 필수적이다.

클린 코드를 해놓으면 나중에 메인터넌스과정에서 엄청난 양의 코드를 이해하는데 매우 효과적이다.

소프트웨어는 추상적이고 보여지는물체가 아니기 때문에 만드는 과정이 복잡하고 이해하기 어렵고 변화를 주려고 할 때 높은 비용(시간,인력등등)이 소모된다. 

판매되는 제품에 대한 소프트웨어의 어떠한 이론 / 어떠한 방법 / 어떠한 도구가 사용되었는지를 공부하는게 소프트웨어공학의 관점이다.

어떠한 소프트웨어 공학 기법을 사용할지는 접근 방법에 따라 다르다.
Web-based information systems  SNS 계속적인 변화 / 고객의 피드백에 따라 변화가 필요
Embedded systems 메모리사용 성능 결함이 없어야 함 등등 자동차ABS시스템 마이크로오븐
Computer games 서버관리

Software failures

만족스러운 결과물이 안나왔을 때
정해진 기간내에 만들지 못했을 때
예상보다 많은 리소스를 사용했을 때

소프트웨어 실패를 겪는 이유
새로운 요구사항이 늘어나면 S/W failures
체계적인 관리가 부족하여 소프트웨어공학기법을 사용하지 않고 시간을 허비하면 S/W failures 될 확률이 높아진다.

Personal software vs professional software

Developed by individuals
Developed by teams, materials ( documentation, tools..)

Generic products (누구나 사용가능한 제품들)
특징: 개발자가 원하는 대로 만들고 사용자가 사용한다.
Customized products (focus on user)
커스터머가 원하는대로 requirements에 맡게 제품을 개발한다.

하지만 점점 구별이 희미해져가고 있다. Generic 프로그램을 만든 후 점점 커스터머에 피드백을 받으면서 그에 맡게 변화시켜나간다. Ex) erp systems such as sap

좋은 소프트웨어의 특징

유저의 요구사항에 맡게 개발된 소프트웨어 (최소한의 조건) /추가적으로 유지보수를 해줄 수 있고 신뢰할 수 있어야한다.

유지보수를 하려면 나중에 코드를 봐도 쉽게 이해할 수 있어 기능을 추가하거나 변경시킬 수 있는 clean code로 작성되있어야 한다.

Software란?
문서가 있는 프로그램 (특정한 고객이 있거나 시장에 판매하기 위해 만든 제품)

소프트웨어공학이란?

소프트웨어 생산의 모든 측면에 관련된 절차를 말한다. 절차란 개발의 과정만을 얘기하는 것이 아니며 프로젝트를 관리하기 위한 도구, 방법등을 얘기한다.

소프트웨어 기본 액티비티

명세 개발 검증 진화

requirements작성
design and implementation 디자인하면서 구현한다. (디자인한 후 구현을 할 수 없다. 디자인을 완벽히 할 수 없기 때문에) interleaved하게 진행한다.
Unit test를 통한 디펙발견 / 코드 검사 & 리뷰
유지보수 단계
워터폴에서는 minor change
에자일에서는 위의단계를 다시 수행하는 것

무엇이 가장 좋은 소프트웨어 공학 기법인가?

어떤 것을 만들지에 따라 다양한 기법들이 사용된다. 예를 들면 게임에서는 계속 다양한 버전의 밸런스 업데이트를 해야하므로 애자일 프로세스가 진행되고
군사시스템에서는 결함이 절대적으로 없어야 하기 때문에 워터폴모델이 적합하다.
Maintainability
소프트웨어는 고객의 변화하는 요구를 충족시킬 수 있어야 한다. 시간이 지남에 따라 소프트웨어의 변경을 필수적이기 때문에 소프트웨어 공학에서 매우 중요한 특성이다.

Dependability
보안 안전 안전성 등등을 얘기한다. 예를들면 해커가 침입을 시도할 때 방어할 수 있고 방어에 실패해도 그 피해를 최소화 할 수 있는 프로그램을 만들어야 한다.

Efficiency
소프트웨어 개발과정에서 낭비되는 리소스가 없어야 한다. 그러기 위해 커스터머의 요구사항에 대해 적절한 기법을 사용하고 적절한 인원이 투입되어야 한다.





Acceptability
설계된대로 소프트웨어가 나와야하며 커스터머한테 납득이 갈 수 있어야 한다. 실제로 사용 가능해야 하며 다른 시스템과 호환이 가능 하도록 만들어야 한다.

소프트웨어 공학이 중요한 이유는 점점 더 기술이 개발되어 더 진화된 소프트웨어를 개발해야 한다. 그 시스템이 개발되는 속도가 빨라 그에 맞춰 신뢰성있고 리소스를 덜 사용해야하며 그 소프트웨어들을 빨리 개발해야 한다.

소프트웨어 과정의 4개의 메인 액티비티

명세 – 다큐멘테이션 SRS
개발 - 디자인앤개발 interleaved (SDD / git)
검증 - 유닛테스트
진화 - 유지보수

소프트웨어기법을 어떻게 정할 수 있나?
만드려는 소프트웨어의 유형
만드려는 소프트웨어의 기업
개발과정에서 포함되는 사람의 수
커스터머의 리콰이어먼트가 어떤 것인지에 따라

CHAPTER 2

Plan driven – waterfall model 100%계획에 맞춰서 실행한다.

Agile method - requirements 에서 불안요소를 확정짓기 힘들기 때문에 나온게 agile method 단계가 끝났다는 것을 팀, 고객과 협의를 해야한다. Incremental development
대략적인 계획을 짜놓고 계획을 계속 단계적으로 붙여나간다. 커스터머의 요구를 반영하기 더 쉽다.

Copying with change
-	Prototyping
-	Incremental delivery

agile method
각 버전마다 완벽해야함

워터폴모델의 단계

리콰이어먼트 분석 및 정의 – 어떤 프로그램을 만들지 목표, 서비스 제약사항

디자인 – 대략적인 시스템 설계 / 모듈별 어떤 기능을 할 것인지

구현 및 유닛 테스트 – 개발하면서 유닛테스트를 진행

integration – 모듈별로 만든 코드를 통합시킨다음 통합된 시스템을 테스트한다

operation and maintenance – 유지보수

waterfall version 의 문제점

다음 단계로 나가기 위해선 그단계가 끝나야만 하는데 그 단계를 확정짓기 어렵고 그 단계가 끝난후 커스터머의 요구사항에 변화에 대한 요구를 들어주기 어렵다.

리콰이어먼트가 확실한경우와 변화가 거의없는 시스템에서 사용하지만 그러한 시스템은 별로 없다.

워터폴 모델은 대형 시스템 개발에 주로 사용된다.

대부분의 경우 인크레멘탈 디벨롭먼트가 워터폴보다 좋다. 개발하는 과정에서 변화를 수용하기 쉽다.
버전이 올라갈수록 기능들이 추가된다. 처음에는 가장 중요한 특징을 설계하고 만든다음 부가적인 시스템을 추가한다.

현재버전에서 요구사항에 맡는 프로그램이 커스터머에게 전달되지 않았을 경우, 다음버전에서 그 요구사항에 맡는 프로그램을 반영한다.

Incremental development
초기버전을 개발하고 그 후 여러번의 버전으로 진화시킴

대략적인 계획을 새우고 (명세 개발 검증)을 한다음 초기버전 여러버전을 거친후 최종버전이 나온다. Mostly agile

incremental development 는 requirements 변화에 대한 비용이 더 적다.
커스터머의 피드백을 더쉽게 개발에 반영할 수 있다.
핵심기능구현이 빠르다.
Waterfall 모델보다 flexible하게 과정이 진행된다.

Incremental development
진행과정이 눈에 보이는 것이 아니기 때문에 진척사항을 예측하기 쉽지 않다. 그러므로 리더의 역할이 중요하다. 문서를 관리하는 것도 힘들기 때문에 코드만 보고도 이해하기 쉽게 리팩토링을 해야하는데 개발하는 틈틈히 시간이 날 때 마다 해주어야 한다.
리팩토링이란 코드기능은 그대로 냅두면서 구조를 쉽게하고 보기쉽게 해주는 것이다.

Reuse는 최근에 대부분의 기업에서 사용하는 스탠다드한 기법인데 reuse를 하기 위해서는 그코드를 정확히 이해하고 있어야 사용할 수 있다.

Spiral model (boehm)
Combine incremental development with the waterfall model (mixed model)
시계방향으로 진행
1cycle 마다 새로운 버전이 나온다.
Cycle내에서의 절차들은 워터폴모델로 진행된다.

2사분면 시작 : 목표를 명확히
1사분면 리스크분석을 한다 (나선형모델의 포인트) 사이클을 줄이려는 노력
4사분면 디자인 코딩 테스팅 릴리스
3사분면 커스터머와 만나 회의를 하는 과정 기능을 추가할 것인지 수정할 것인지등등
실제 회사에서는 프로세스 – 액티비티 – 태스크로 과정이 나뉨 아래로 갈수록 세부적임

process activities

4가지 기본 프로세스 액티비티

specification
requirement – functional / non functional 로 나뉨
F기능 특징 디자인(아웃라인 인터페이스 구조)
NF품질 performance reliability maintainability deadline cost

design and implementation – interleaved 한 development

validation 요구사항을 만족하는지 테스팅 유닛테스트

evolution – version up (유지보수)

디자인
실행되는 소프트웨어의 구조를 묘사한다.

디자인의 4단계

아키텍쳐 디자인 – 큰그림 / 각각역할정의 (핵심 컴포넌트만)
인터페이스 디자인 – 구체적으로 어떻게 정의 하고 있는지 / API / 함수이름이 뭐고 / 어떤 파라미터를 줘야하는지/ 리턴값정의
컴포넌트 디자인 – 디테일하게 내부를 어떻게 정의하는지

데이터베이스 디자인 – 필요하지 않을 경우 없어도 된다. 만약 어떤 정보를 데이터화시키고 저장시켜야 한다면 데이터베이스 디자인이 필요하다.

Implementation 개인스타일에 맡긴다. 애자일메소드일 경우엔 거의 건드리지 않는다.
컴포넌트마다 유닛테스트를 해주어 디펙을 발견하고 그 디펙을 수정한다.

validation
리콰이어먼트에 맞는 소프트웨어가 나왔는지

컴포넌트테스팅 (unit testing)
각각의 컴포넌트들을 독립적으로 테스트한다.
컴포넌트 (함수, 클래스, 그룹핑된 엔티티)
테스트 오토메이션 툴을 사용한다 ex) junit, cppunit cunit pyunit …..

system testing
전체적인 시스템을 검사하는 것이며 F requirements 와 NF requirements를 충족하는지 검사한다.

acceptance testing (사용자가돌려봄)
실제 시장에서 쓰이기 전에 하는 최종테스트이다.
커스터머의 요구에 부합하는지 체크해본다.
Alpha testing 이라고도 불린다. 커스터머와 개발자가 만나 시스템을 실행해 리콰이어먼트에 만족하고 동의하는지를 본다.

Beta testing 시스템을 마켓에 출시시켜보고 커스터머로 부터 피드백을 받아 수정하거나 재출시한다.

실제로 개발과 테스팅은 인터리브드한 과정을 거친다.

V-Model
테스트단계를 디테일하게 펼쳐놓고
개발단계의 순서와 짝을 이루어 테스트를 진행해나가는 방법이다.
V모델은 개발과 관련한 다양한 단계를 표현하고 있는데 시험과 요구사항의 관계에 기반을 두고 있다. 일반적으로 V모델에서는 개발을 Layer 구조로 보고 각각의 대응 계층에서 대응하는 개발단계에 적합한 관심사항을 다룬다. 이러한 V 모델은 검증을 강조한 모델이며, Waterfall 모델의 확장된 형태로 볼 수 있다.  


p.45
evolution
애자일에서 주로함
변화하는 비즈니스 상황에서 리콰이먼트 변경을 필수이다.


p.48
소프트웨어 – 출시하는순간변화가필요

변화는 필수불가결 어떻게 적은 비용으로 할 수 있나?

언제 체인지가 일어나나
Requirements change
사용자들의 요구사항으로 인해
new design and implementation possibilities emerge
새로운기술이 이용 가능 할 때
platform changes
앱을 뉴버전에 실행가능하게 만들어 줘야 한다.


p.49 두가지만 얘기함 (오늘 핵심적으로 얘기함)

rework overhead를 줄이기 위해 아래 2가지를 쓴다.

프로토타이핑 (만들어서 보여줘보고 피드백을 얻어서 진행시킨다.)
인크레멘탈 딜리버리 – 몇가지 규율을 더 지켜주면 에자일 메쏘드
현업에 쓸수있게 가져다 주는것이 핵심!!!!

프로토타이핑

껍데기가 불확실할 때 ex. GUI / CLI,  서버를 구현할 때 1000명을 수용할수있나 확인해보는 것 feasible하는지 확인해보는 용도

p.51 incremental delivery의 예
1->2->3->4->5
결국엔 인크레멘탈 딜리버리가 에자일 메쏘드이다

p.52
프로토타이핑은 빨리만들고 확인하고 버릴수도있고 재사용하기 힘들다.
핵심은 빨리빨리 만드는 것

빨리만들어서 보고싶은거 확인해보고 (한부분만체크한다)

requirement가 불확실할때 확인해보고
디자인이 통할까 할때 빨리 만들어서 확인 해본다.

프로토타이핑
시스템이 사용성 증가 (고객이 요구했으니까)
사용자에게 맞는 
디자인 퀄리티 (사용자가 피드백을줬으니까)
줄어든 개발에 대한 노력
p.54 프로토타이핑 순서

목표를 확실히 정의 – 프로토타입의 기능 정의 (디자인이 불확실하다) – 프로토타입개발 – 프로토타입평가

프로토타입
{
필요없는 기능은 만들지 않는다. 
non functional requirements 고려 x (메모리,스피드 고려 x)
에러 무시 / 퀄리티 무시
}

프로토타입핑의 문제 p.55

재활용가능성이거의없다
문서도 없을테고
구조도 개판일테고
고쳐서 쓸 필요가 없다.
잘못된 피드백을 받을 수 있는 위험이 있다.
오해유발가능
p.56 incremental delivery

워터폴 – 싱글딜리버리
여러개의 구역으로 나눠서 실행 - 인크레멘탈딜리버리

1달씩 기능일부를 제대로 보여줌
계획을 잘게 쪼개서 한다.


Y축 고객이 받는 가치의 양

Incremental development , Incremental delivery

같은점 
인크레멘탈적으로 만든다.

다른점 
실제로 사용자가 사용할 수 있게 만든다.
시스템이 계속 바뀌어서 바뀔때마다 환경에 익숙해져야하는 단점이 있다.

p.58 엄청중요하다!

빈칸뚫어놓고 내는 문제는 나오지 않음

대략적 리콰이어먼트를 아웃라인으로 확인 – 리콰이어먼트를 기반으로 계획을 짬 – 디자인을 해본다 – develop system increment (첫번째 버전을 만듬) – 만든것을 테스트 – 통합 – 통합된거검증 – 새로운인크레멘트 or final system

p.59, 60 (중요)
incremental delivery에서는 커스터머의 역할의 중요하다.
뭐가 필요한지 결정을 해주어야 하고 수정사항을 정확히 얘기해주어야 한다.

P.61 incremental delievery 장점
프로토타입에 비해 인크레멘탈 딜리버리는 리얼 현실에서 쓸수있다.
계속해서 변경을 주는 기법이므로 큰변화는 일어나지 않음

p.62 
나쁜 코드/구조 유발


p.63
agile에서는 specification를 productbacklog이라고 부름

p.64
CMM 모델
Capability maturity model 능력성숙도모델

p.66
프로세스로 점수를 매겨 수치화한다. 레벨1에서 레벨5까지 있음

에자일 어프로치
오버헤드를 줄인다
알아서 놔두면 생산성이 좋아질거라 기대

p.67
measure
현상황 디펙의개수

analyze
문제를 찾아내는단계

change
문제를 해결하는 단계

프로세스 metrics 정량적인 과정을 데이터로 표현

액티비티마다 시간을 재는것
투입된자원의량 (사람,돈)
특정한일이 일어난 횟수 (발견된 디펙의수)


p.69 중요함!

원래의도는 회사를 평가
미국방성에서 개발함 SEI
목표는 기존에있는 소프트웨어 디벨롭먼트 프로세스를 발전시키는것

레벨1 이니셜 (프로세스가 없는 단계) 아무것도 안하는 다계

레벨2 매지지드 리피터블 (프로세스를 문서화는해놓음/하면 한다라는 느낌) repeatable
규정은있는데 안지켜도 뭐라 하지 않음 / 따라해볼수있음

레벨3 디파인드 (규정존재 규정을 지키는 단계) / 규정에 따라 진행하는 단계

레벨4 quantitatively managed 매니지드 / 수치들을 다 관리하고 통제도 잘되는 단계 / 프로세스 액티비티 수치들을 관리되고 있는가 / 수치적 숫자적으로 관리
monitoring information 

레벨5 optimizing
프로세스를 활용해서 스스로 문제를 찾아내서 스스로 개선할 수 있다.
숫자를 기반으로 self improve 가능

Initial repeatable defined managed optimizing


CHAPTER 3
Agile Software Development

이런원칙을지키면 애자일이라고 하자

extereme programming 2주마다 변경
Scrum
Kanban

RAPID DEVELOPMENT 프로젝트 쾌속 개발 전략

p.4 
configuration management tool X
automated testing tools 써라!!

p.7 (중요) 에자일 선언문

p.11 에자일메소드의 핵심원칙

커스터머도 개발에 참여 (리콰이어먼트 피드백 / 테스팅에 대한 피드백)
인크레멘탈딜리버리 (반복해서 전달 / 바로바로 쓰게 만들자)
사람에게 맡겨라 (절차를 만들지 말고 맡겨라 / 강한 팀워크필요 결속력)
변화를수용하자 (새로운 버젼을 계속 만들어 나가자)
소프트웨어 단순성을 유지 (코드심플 / 읽기쉬워야함 / 다음버전에있을기능만포함)

12/29 agile method practice중점

p.12 에자일메소드환경
개발팀원이작아야함 (최대8명)
커스터머가 반드시 개발과정에 참여해야함 (피드백 테스팅) 의무감을 가지고
규제 / 규율 및 외부규정이 있으면 함부로 에자일을 쓰기 쉽지 않다

#라지스케일에자일메소드가 생기고 있음

에자일의문제점 p.13

커스터머의 참여유도를 하는게 쉽지 않다.

팀원간의 결속력 (아침마다 팀미팅을 함) 문제점 상황 등등 공유 daily scrum

여러 고객이 있을 때 우선순위를 정하기 어렵다

단순성을 유지 하는데 부가적인 비용이 든다. (리팩토링걸리는 시간 코드를 끊임없이 깔끔히 수시로 하는것임)

계약을 맺기 쉽지 않다. 협의를 보기 어려움. 대부분기간으로 정함. 아웃풋이 어떻게 나올지 모른다.

p.15
커스터마가 열심히 피드백을 줘야 agile을 고려하고 성공가능성이 높아진다.

기본적으로 에자일은 규모가 작고 한곳에 모여있어야함
규모가 커서 물리적으로 분산되기 시작하면 스케쥴링을 팀별로 플랜드리븐

p.16
조직문화에 따라 플랜드리븐 에자일이 결정

p.17
에자일메소드 = 에자일프로그래밍


계획을안해도되니까 코딩에 노력이 들어가고 계속 고쳐줘야하니까 리팩토링이 필요하다.

p.18 extreme programming

초반에 나온 기술 중 파격적인 기술 / 이 기법이 다른 기법에 영향을 많이줌

people not process -> pair program 이 나옴 ( 2인1조 )
리팩토링을계속하라

2주마다 인크레멘탈 딜리버리
모든 코드의 테스트가 통과되야 올릴 수 있음

p.19
인크레멘탈딜리버리를 small frequent

customer involvement   full time

pair programming / 패어가 계속바뀜 / 야근금지

주기적으로 새로운 제품이 간다.

단순성유지를 위해 리팩토링를 꼭 해라

p.21 XP규율들

유닛테스트 – 테스트커버리지 (test lag) / 내가짜고싶은것을명확히하기위해

리팩토링 – 모든개발자는 항상 리팩토링을 해야한다. (코드를 심플하고 매인터너블하게 만들수있다.) -> (나중에 고칠 수 있게 하는 것이다.)

공동책임 – 한사람의 잘못이 아니다.

Continuous integration 강조 – 시험에는 안나옴 / 나올수도?

인테그레이션이 날을 잡아서 주기적으로 일어난다. 유닛테스트는 반드시 실행되고 패스되어야 한다.

(Sustainable pace)일을 적당히 ~

on site customer 커스터머가 현장에 와서 피드백을 주는 것

p.23
key practices
1	User stories - 
2	Refactoring - 
3	Test
4	-first development - 
5	Pair programming – 

P.30
Variables 명사 객체
Methods 동사 액션,움직임

p.36
test case

어떤입력을넣어볼것인지
무엇을 테스트할지
어떤값이나오는지정의



p.39
독립적인 기능

모든 항목이 테스트에 통과해야함 하나라도 빠지면 안된다.

p.41

코드 리뷰하는 사람
속도는 느려지지만 나쁘지는건 아님
고칠일이 줄어듬

p.43
공동책임 소유권도 공동소유


p.45 스크럼
프로시져 큰그림
큰틀 사이클을 정의

팀에 강한 인터렉션필요 공동의 목표를 달성한다

크게3단계   - 2번째단계가 중요하다
1 – outline 사전준비작업 큰그림 목적 아키텍처를 잘 설계
2 – 스프린트(중요!) 한사이클을 돌면 새로운 버전이 나온다.
3 – 마무리단계 필요한문서 작업 
assess 평가
product backlog  - userstory 의 총 집합 / 전체에서 해야할일들
파리이어리티 정렬 중요도 다음버전에 무엇을 할지

select 다음버전에 들어갈 기능 선택 ( 개발자와 커스터머 같이 상의)
선택된 것들은 이번 스프린트에 해야할일 sprint backlog

develop – 개발을 하면 됨 특별한 절차는 없지만 daily scrum 해주면됌

review 잘만들어졌는지 커스터머랑 검토 피드백
potentially shippable

daily scrum  - 상황정리 오늘할거 무슨문제가있는지 공유하는 시간 / 지시를 내리는게 아님
역할이 정해져있진 않지만 스프린트마다 역할이 있을 수 있다.

스크럼의 장점
애자일의 장점을 고스란히 가지고 있다
일을 여러개 매니지가 가능한 작은 규모로 쪼개서 한다.

항상 주긴준다. 예상치못하게 못주더라도 나머진 완벽히 돌아가는 시스템을 준다. 받으면 피드백을줌

 

p.56 칸반
토요타 제조업프로세스 -> 소프트웨어프로세스

2주가 큰걸만들기 부담되고 큰일을 못함 무조건 2주안으로 쪼개야하는 불편함 억지로 끊는 경우가 있다

롱러닝프로세스의경우 스크럼에서는 할 수가 없다

작업의단계를 얘기한다.

작업현황을 눈으로 묘사한다.
Pull based work in progress
보드에서 빠져나오면 새로운버젼이 나온다.

Continuous 하게 deliver가 된다.

Work flow용어를 많이씀

Bottle neck이 생길 수 있어서 계속 옵티마이징을 해주어야 한다.

scrum
2-4 weeks
cadence (2-4 weeks 얘기)
예상되는 기간에 튀어나온다.
특별한 롤이 없다. 플랫한 구조 / 전담하는 일이 없다.
일정한규칙이있다

Kanban
No fixed length / 우선순위 백로그
Release occur continuously
전문성을 가지고 전담하는 인력이 약간 있다.
너무 많이 전문적인 일만 시키면 팀의 효율성을 떨어뜨린다.
Continually improving processes
우선순위가 낮은 작업이 있어서 계속 진행이 안될 때는 부가적인 규칙을 정해줘서 해결한다.

UML
소프트웨어를 그림으로 표현하는 언어
다이어그램

개발전에 개발할거를 묘사하기 위해서도 쓰고 / 개발하고 난다음 개발한것을 묘사하기 위해도 쓰고

요즘에는 스케치로만 거의씀
전달하고 싶은 측면을 UML로 표현 selective communication

